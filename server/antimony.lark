
var_name : ["$"] NAME
in_comp : "in" var_name
name_maybe_in : var_name [in_comp]


reaction : [name_maybe_in ":"] reactants _ARROW products ";" rate_law [in_comp]
reactants : species ("+" species)*
products : species ("+" species)*
species : [NUMBER] var_name
?rate_law : sum
_ARROW : "->"
    | "=>"


assignment : name_maybe_in "=" sum


annotation : var_name annot_keyword ESCAPED_STRING
annot_keyword : "identity"      -> identity
    | "hasPart"                 -> has_part


declaration : declaration_modifiers declaration_item ("," declaration_item)*
declaration_modifiers : var_modifier
    | var_type
    | var_modifier var_type
declaration_item : name_maybe_in [decl_assignment]
decl_assignment : "=" sum

var_modifier : "var"            -> var
    | "const"                   -> const
var_type : "species"            -> species
    | "compartment"             -> compartment
    | "formula"                 -> formula


?sum : product
    | sum "+" product           -> add
    | sum "-" product           -> sub

?product : exponential
    | product "*" exponential   -> mul
    | product "/" exponential   -> div

?exponential: atom
    | exponential "^" atom      -> exp

?atom : NUMBER                  -> number
    | NAME                      -> var
    | "-" atom                  -> neg
    | "(" sum ")"


?full_statement : [statement] _STATEMENT_SEP
?statement : reaction
    | assignment
    | declaration
    | annotation
_STATEMENT_SEP : _NL
    | ";"


// For some reason we need to have at least one full_statement in the model, even if it is just
// a newline or a semicolon
model : ("model" | "module") NAME full_statement+ "end"


root : (full_statement | model)*


_NL: NEWLINE


%import common.CNAME -> NAME
%import common.NUMBER
%import common.DIGIT
%import common.LETTER
%import common.WS
%import common.WS_INLINE
%import common.NEWLINE
%import common.ESCAPED_STRING
%ignore WS_INLINE
