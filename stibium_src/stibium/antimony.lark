
var_name : ["$"] NAME
in_comp : "in" var_name
namemaybein : var_name [in_comp]

reaction_name : namemaybein ":"
reaction : [reaction_name] species_list ARROW species_list ";" sum [in_comp]
species_list : species ("+" species)*
species : [NUMBER] var_name
ARROW : "->"
    | "=>"

assignment : namemaybein "=" sum

annotation : var_name ANNOT_KEYWORD ESCAPED_STRING
ANNOT_KEYWORD .2: "identity" | "hasPart"   // use .2 to specify higher priority when matching


declaration : decl_modifiers decl_item ("," decl_item)*
decl_modifiers : VAR_MODIFIER
    | TYPE_MODIFIER
    | VAR_MODIFIER TYPE_MODIFIER
decl_item : namemaybein [decl_assignment]
decl_assignment : "=" sum

VAR_MODIFIER .2: "var" | "const"
TYPE_MODIFIER .2: "species" | "compartment" | "formula"

?sum : product
    | sum "+" product
    | sum "-" product

?product : power
    | product "*" power
    | product "/" power

?power: atom
    | power "^" atom

?atom : NUMBER
    | NAME
    | "-" atom                  -> neg
    | "(" sum ")"


?simple_stmt : [small_stmt] STMT_SEPARATOR
?small_stmt : reaction
    | assignment
    | declaration
    | annotation
STMT_SEPARATOR : _NL
    | ";"


// For some reason we need to have at least one suite in the model, even if it is just
// a newline or a semicolon
model : ("model" | "module") NAME simple_stmt+ "end"


// TODO rename to 'file'
root : (simple_stmt | model)*


_NL: NEWLINE


%import common.CNAME -> NAME
%import common.NUMBER
%import common.DIGIT
%import common.LETTER
%import common.WS
%import common.WS_INLINE
%import common.NEWLINE
%import common.ESCAPED_STRING
%ignore WS_INLINE
